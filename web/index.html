<!doctype html>
<html>

<head>
    <script src="js/pixi.js"></script>
    <script src="js/functions.js"></script>
</head>

<body>
    <script>
        const gridWidthBlocks = 10;
        const gridHeightBlocks = 10;
        const blockWidth = 50;
        const blockHeight = 50;

        let teamANextMove = null;
        let teamBNextMove = null;


        const width = (gridWidthBlocks * blockWidth) + (2 * blockWidth);
        const height = (gridHeightBlocks * blockHeight) + (2 * blockHeight);

        const board = {
            teamA: {
                spriteImage: "images/tankA.png",
                tanks: [
                    {
                        x: 0,
                        y: 0,
                        status: "active"
                    },

                    {
                        x: 0,
                        y: 1,
                        status: "active"
                    },

                    {
                        x: 0,
                        y: 2,
                        status: "active"
                    }
                ]
            },
            teamB: {
                spriteImage: "images/tankB.png",
                tanks: [
                    {
                        x: 9,
                        y: 9,
                        status: "active"
                    },

                    {
                        x: 9,
                        y: 8,
                        status: "active"
                    },

                    {
                        x: 9,
                        y: 7,
                        status: "active"
                    }
                ]
            }
        }

        // World is going to be a 10x10 gris with 50 px by 50px. There will be a border with 50px.
        let app = new PIXI.Application({ width: width, height: height });
        document.body.appendChild(app.view);

        // Initial drawing

        const teamASprites = [];
        const teamBSprites = [];

        drawWalls();
        drawFloor();
        InitialDrawing(board.teamA, teamASprites);
        InitialDrawing(board.teamB, teamBSprites);


        let elapsed = 0.0;

        //every Frame to be rendered
        app.ticker.add((delta) => {
            updatePostion(board.teamA, teamASprites);
            updatePostion(board.teamB, teamBSprites);

            // elapsed += delta;
            // tank.x = blockWidth + ( 100.0 + Math.cos(elapsed / 50.0) * 100.0);
            // tank.y = blockHeight;
        });


        const webSocket = new WebSocket('ws://localhost:8080', "boardProtocol");
        webSocket.binaryType = "arraybuffer";

        let webSocketReady = 0;

        webSocket.onopen = (event) => {
            webSocketReady = 1;
            console.log("Websocket open.");
        };

        webSocket.onmessage = (event) => {
            try {
                var enc = new TextDecoder("utf-8");
                obj = JSON.parse(enc.decode(event.data));

                console.log(obj)


                if (obj.from === "board") {
                    console.log("Own echo");
                }

                if (obj.from === "teamA") {
                    console.log("team A input")
                    console.log(obj)
                    teamANextMove = obj;
                }

                if (obj.from === "teamB") {
                    console.log("team B input");
                    teamBNextMove = obj;
                }

            }
            catch (err) {
                console.error(err);
                console.log("Input ignored");
            }

        }

        webSocket.onerror = (error) => {
            console.log(error);
            console.log("WebSocket error");
            alert("Websocket error. Refresh page to restart");
        }

        webSocket.onclose = () => {
            console.log("WebSocket closed");
            alert("Websocket closed. Refresh page to restart");
        }


        // update every turn
        let turnClock = setInterval(updateTurn, 1000);


        function updateTurn() {
            // ToDo:
            // Check if they are moving on the top of each other


            
            // update based on moves
            if (teamANextMove)
                for (let i = 0; i < board.teamA.tanks.length; i++) {
                    if (teamANextMove.move[i] === "moveUp")
                        if (board.teamA.tanks[i].y !== 0)
                            board.teamA.tanks[i].y = board.teamA.tanks[i].y - 1;
                    if (teamANextMove.move[i] === "moveDown")
                        if (board.teamA.tanks[i].y !== gridHeightBlocks - 1)
                            board.teamA.tanks[i].y = board.teamA.tanks[i].y + 1;
                    if (teamANextMove.move[i] === "moveLeft")
                        if (board.teamA.tanks[i].x !== 0)
                            board.teamA.tanks[i].x = board.teamA.tanks[i].x - 1;
                    if (teamANextMove.move[i] === "moveRight")
                        if (board.teamA.tanks[i].x !== gridWidthBlocks - 1)
                            board.teamA.tanks[i].x = board.teamA.tanks[i].x + 1;

                }

            if (teamBNextMove)
                for (let i = 0; i < board.teamB.tanks.length; i++) {
                    if (teamBNextMove.move[i] === "moveUp")
                        if (board.teamB.tanks[i].y !== 0)
                            board.teamB.tanks[i].y = board.teamB.tanks[i].y - 1;
                    if (teamBNextMove.move[i] === "moveDown")
                        if (board.teamB.tanks[i].y !== gridHeightBlocks - 1)
                            board.teamB.tanks[i].y = board.teamB.tanks[i].y + 1;
                    if (teamBNextMove.move[i] === "moveLeft")
                        if (board.teamB.tanks[i].x !== 0)
                            board.teamB.tanks[i].x = board.teamB.tanks[i].x - 1;
                    if (teamBNextMove.move[i] === "moveRight")
                        if (board.teamB.tanks[i].x !== gridWidthBlocks - 1)
                            board.teamB.tanks[i].x = board.teamB.tanks[i].x + 1;

                }

            // update based on fire
            if (teamBNextMove)
                for (let i = 0; i < board.teamB.tanks.length; i++) {
                    // if (teamBNextMove.move[i] === "fireUp")

                    // if (teamBNextMove.move[i] === "fireDown")

                    // if (teamBNextMove.move[i] === "fireLeft")

                    // if (teamBNextMove.move[i] === "fireRight")

                }


            // reset desired move
            teamANextMove = null;
            teamBNextMove = null;

            // send the current board information
            if (webSocketReady) {
                webSocket.send(JSON.stringify({
                    ...board,
                    from: "board"
                }));
            }
            else {
                console.error("Websocket not ready.");
            }
        }


        function shuffle(array) {
            let currentIndex = array.length, randomIndex;

            // While there remain elements to shuffle.
            while (currentIndex != 0) {

                // Pick a remaining element.
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;

                // And swap it with the current element.
                [array[currentIndex], array[randomIndex]] = [
                    array[randomIndex], array[currentIndex]];
            }

            return array;
        }

    </script>
</body>

</html>